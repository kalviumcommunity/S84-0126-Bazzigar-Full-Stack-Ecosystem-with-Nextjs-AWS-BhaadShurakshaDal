// Bhaad Suraksha Dal - Database Schema
// A fully normalized relational database for emergency response management
// Using PostgreSQL with Prisma ORM

datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

// ============================================================================
// ENUMS
// ============================================================================

/// Member roles in the system
enum MemberRole {
  ADMIN
  COMMANDER
  VOLUNTEER
}

/// Complaint status for transaction management
enum ComplaintStatus {
  FILED
  UNDER_REVIEW
  APPROVED
  REJECTED
  CLOSED
}

/// Payment status for transaction management
enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

/// Status of a duty/assignment
enum DutyStatus {
  PLANNED
  ONGOING
  COMPLETED
  CANCELLED
}

/// Priority level of a duty
enum DutyPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

/// Types of incidents that can be reported
enum IncidentType {
  INJURY
  ACCIDENT
  SECURITY_THREAT
  PROPERTY_DAMAGE
  HEALTH_EMERGENCY
  FIRE
  NATURAL_DISASTER
  CIVIL_UNREST
  OTHER
}

/// Severity level of an incident
enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

/// Status of an incident report
enum IncidentStatus {
  OPEN
  UNDER_INVESTIGATION
  RESOLVED
  CLOSED
}

/// Status of a case
enum CaseStatus {
  OPEN
  UNDER_REVIEW
  IN_PROGRESS
  RESOLVED
  CLOSED
}

/// Priority level of a case
enum CasePriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// ============================================================================
// MODELS
// ============================================================================

/// Members of the Bhaad Suraksha Dal organization
model Member {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String   @db.VarChar(255)
  phone         String   @unique
  role          MemberRole
  dateOfJoining DateTime @default(now())
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  teamLeaderships    Team[]           @relation("LeadedBy")
  teamMemberships    TeamMembership[]
  dutyAssignments    Duty[]           @relation("CreatedBy")
  incidentReports    IncidentReport[] @relation("ReportedBy")
  casesReported      Case[]           @relation("ReportedBy")
  casesAssigned      Case[]           @relation("AssignedTo")
  complaintsFiled    Complaint[]      @relation("ComplaintsFiled")
  approvalsGiven     ApprovalRecord[] @relation("ApprovalsGiven")
  paymentsReceived   Payment[]        @relation("PaymentsReceived")
  reliefFund         ReliefFund?      @relation("ReliefFund")

  @@index([email])
  @@index([phone])
  @@index([role])
  @@index([isActive])
  @@map("members")
}

/// Teams composed of multiple members
model Team {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(255)
  description String?  @db.Text
  leaderId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  leader       Member           @relation("LeadedBy", fields: [leaderId], references: [id], onDelete: Restrict)
  members      TeamMembership[]
  duties       Duty[]

  @@index([leaderId])
  @@index([name])
  @@map("teams")
}

/// Junction table for Team-Member many-to-many relationship
model TeamMembership {
  id        String   @id @default(cuid())
  teamId    String
  memberId  String
  joinedAt  DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([teamId, memberId])
  @@index([teamId])
  @@index([memberId])
  @@map("team_memberships")
}

/// Duties/assignments allocated to teams
model Duty {
  id            String      @id @default(cuid())
  title         String      @db.VarChar(255)
  description   String?     @db.Text
  teamId        String
  startDateTime DateTime
  endDateTime   DateTime
  status        DutyStatus  @default(PLANNED)
  location      String      @db.VarChar(255)
  priority      DutyPriority @default(MEDIUM)
  createdById   String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  team              Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdBy         Member            @relation("CreatedBy", fields: [createdById], references: [id], onDelete: Restrict)
  incidentReports   IncidentReport[]

  @@index([teamId])
  @@index([createdById])
  @@index([status])
  @@index([priority])
  @@index([startDateTime])
  @@index([endDateTime])
  @@map("duties")
}

/// Incident reports filed during duties
model IncidentReport {
  id            String           @id @default(cuid())
  dutyId        String
  reportedById  String
  incidentType  IncidentType
  severity      IncidentSeverity
  description   String           @db.Text
  location      String           @db.VarChar(255)
  reportedAt    DateTime         @default(now())
  status        IncidentStatus   @default(OPEN)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  duty       Duty   @relation(fields: [dutyId], references: [id], onDelete: Cascade)
  reportedBy Member @relation("ReportedBy", fields: [reportedById], references: [id], onDelete: Restrict)

  @@index([dutyId])
  @@index([reportedById])
  @@index([status])
  @@index([severity])
  @@index([incidentType])
  @@index([reportedAt])
  @@map("incident_reports")
}

/// Cases represent formal issue tracking for incidents and emergency management
/// Each case links to a reporter and optionally an assigned handler
/// This demonstrates a one-to-many relationship: Member → Case
model Case {
  id           String      @id @default(cuid())
  title        String      @db.VarChar(255)
  description  String      @db.Text
  status       CaseStatus  @default(OPEN)
  priority     CasePriority @default(MEDIUM)
  reportedById String
  assignedToId String?
  reportedAt   DateTime    @default(now())
  resolvedAt   DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // Relations
  reportedBy Member  @relation("ReportedBy", fields: [reportedById], references: [id], onDelete: Restrict)
  assignedTo Member? @relation("AssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)

  @@index([reportedById])
  @@index([assignedToId])
  @@index([status])
  @@index([priority])
  @@index([reportedAt])
  @@index([resolvedAt])
  @@map("cases")
}

/// Complaints registered by community members
/// Demonstrates transaction scenario: complaint filing + member status update
model Complaint {
  id          String          @id @default(cuid())
  title       String          @db.VarChar(255)
  description String          @db.Text
  memberId    String
  status      ComplaintStatus @default(FILED)
  severity    IncidentSeverity @default(MEDIUM)
  location    String          @db.VarChar(255)
  filedAt     DateTime        @default(now())
  resolvedAt  DateTime?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  
  // Relations
  member        Member @relation("ComplaintsFiled", fields: [memberId], references: [id], onDelete: Cascade)
  approvalRecord ApprovalRecord?

  // Indexes for transaction queries
  @@index([memberId])
  @@index([status])
  @@index([severity])
  @@index([filedAt])
  @@index([resolvedAt])
  @@map("complaints")
}

/// Approval records for complaint complaints
/// Demonstrates transaction scenario: complaint approval + fund allocation
model ApprovalRecord {
  id           String   @id @default(cuid())
  complaintId  String   @unique
  approvedById String
  amountAllocated Decimal @db.Decimal(10, 2)
  approvalDate DateTime @default(now())
  notes        String?  @db.Text
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  complaint  Complaint @relation(fields: [complaintId], references: [id], onDelete: Cascade)
  approvedBy Member    @relation("ApprovalsGiven", fields: [approvedById], references: [id], onDelete: Restrict)

  @@index([complaintId])
  @@index([approvedById])
  @@map("approval_records")
}

/// Payment records for relief fund disbursements
/// Demonstrates transaction scenario: payment processing + fund balance update
model Payment {
  id              String        @id @default(cuid())
  complaintId     String
  memberId        String
  amount          Decimal       @db.Decimal(10, 2)
  status          PaymentStatus @default(PENDING)
  paymentMethod   String        @db.VarChar(50)
  transactionId   String?       @unique @db.VarChar(100)
  processedAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  member        Member    @relation("PaymentsReceived", fields: [memberId], references: [id], onDelete: Cascade)

  // Indexes for transaction queries
  @@index([memberId])
  @@index([complaintId])
  @@index([status])
  @@index([processedAt])
  @@map("payments")
}

/// Fund tracking for relief distribution
/// Demonstrates transaction scenario: balance updates during payment processing
model ReliefFund {
  id              String   @id @default(cuid())
  memberId        String   @unique
  totalAllocated  Decimal  @db.Decimal(12, 2) @default(0)
  amountDispersed Decimal  @db.Decimal(12, 2) @default(0)
  lastUpdated     DateTime @default(now()) @updatedAt
  createdAt       DateTime @default(now())

  // Relations
  member         Member @relation("ReliefFund", fields: [memberId], references: [id], onDelete: Cascade)

  @@index([memberId])
  @@map("relief_funds")
}

// ============================================================================
// SCHEMA DOCUMENTATION
// ============================================================================
// 
// DATABASE NORMALIZATION:
// - 1NF: All attributes are atomic; no repeating groups
// - 2NF: All non-key attributes fully depend on primary key
// - 3NF: No transitive dependencies between non-key attributes
//
// RELATIONSHIPS:
// - Member → Team: One-to-Many (1 Member leads multiple Teams)
// - Member ↔ Team: Many-to-Many (via TeamMembership junction table)
// - Team → Duty: One-to-Many (1 Team has many Duties)
// - Duty → IncidentReport: One-to-Many (1 Duty has many IncidentReports)
// - Member → IncidentReport: One-to-Many (1 Member files many Reports)
// - Member → Case: One-to-Many (1 Member can report/be assigned multiple Cases)
//
// CONSTRAINTS:
// - CUID as primary keys for distributed systems
// - UNIQUE on email, phone, team name to prevent duplicates
// - NOT NULL on critical fields
// - ON DELETE CASCADE for dependent records
// - ON DELETE RESTRICT to prevent orphaning
// - ON DELETE SET NULL for optional foreign keys (Case.assignedToId)
//
// INDEXES:
// - Foreign keys indexed for join performance
// - Status and priority indexed for filtering queries
// - Timestamps indexed for range queries
// - Email/phone indexed for lookup queries
